# CHAPTRER 02. 인터페이스와 클래스

# 2.1 Summary
* 인터페이스의 변화 
  * 함수형 프로그래밍 / 스트림의 등장 배경
* 인터페이스에 default, static, private 메서드 추가 가능 (자바 버전 업그레이드에 따라 인터페이스에 정의할 수 있는 항목들이 늘어남 )
* 다중 상속 및 다이아몬드 상속 발생 가능
  * 인터페이스와 클래스 간의 상속 관계와 호출 관계에 대한 명확한 이해 필요
  * 다중 상속으로 인한 메서드 호출이 모호해지지 않도록 super 키워드를 이용하여 호출할 인터페이스의 default 메서드를 명시적으로 지정해야 함

# 2.2 인터페이스 사용 시 문제점
## 2.2.1 인터페이스란?
* 여러 개의 구현체를 통일화된 명세서를 정의하기 위해 사용 (메서드 이름의 통일성 확보)
* 구현 방법에 상관 없이 자신이 원하는 메서드를 호출하여 사용 가능
* _인터페이스는 추상클래스처럼 그 자체로 인스턴스 생성이 불가능함 -> 추상 메서드를 모두 구현해야 함_
  * _인터페이스의 추상 메서드를 모두 구현하지 않은 경우, 해당 클래스에 abstract 키워드를 붙여서 추상클래스로 만들어야 함._
* 클래스와는 달리 다중 상속 가능 (여러개의 인터페이스로부터 상속 받는 것 가능)
>* AS-IS: 오직 추상 메서드(public abstract)와 상수(public static final)만을 멤버로 가질 수 있음 (접근 제어자는 생략 가능)
>* TO-BE: Java8 부터 static / defualt 메서드 추가 가능 

## 2.2.2 한번 배포된 인터페이스는 수정이 어려움

* 인터페이스 배포 후 해당 인터페이스를 구현한 모든 클래스에서 개발 시점에 컴파일 에러 발생 (그러나 모든 클래스를 한번에 수정하는 것은 불가능)
* 클래스를 수정하지 않고 인터페이스를 컴파일해서 배포한 후 일부 소프트웨어 실행 환경에서 NoSuchMethod 에러가 발생
> [Step01] CompanyEncryption 인터페이스에서 encrypt, decrypt 메서드 유지한 채 isEncoded 메서드 추가시 문제 발생
```java
public interface CompanyEncryption {
	/**
	 * 파라미터 값을 표준 알고리즘으로 인코딩 한다.
	 * @param bytes
	 * @return
	 */
	public byte[] encrypt(byte[] bytes) throws Exception;
	
	/**
	 * 인코딩된 문자를 표준 알고리즘으로 디코딩 한다.
	 * @param bytes
	 * @return
	 */
	public byte[] decrypt(byte[] bytes) throws Exception;
	
	/**
	 * [추가] 파라미터 값이 암호화 알고리즘으로 인코딩 되었는지 확인한다.
	 * @param bytes
	 * @return
	 * @throws Exception
	 */
  // public boolean isEncoded(byte[] bytes) throws Exception;
}
```

> [Step02] isEncoded 메서드를 별도의 인터페이스로 만들어서 배포
* 컴파일 에러나 NoSuchMethod에러는 피할 수 있지만
* 추가로 메서드가 필요/기존 메서드에 인수 추가해야 할 때마다 인터페이스를 하나씩 새로 만들 수는 없음!

> [예시] Collection과 List 인터페이스
* list와 Collection 인터페이스는 Java 1.2/8이후 추가 : 영향도가 너무 컸기 때문에 중간 버전에서 추가하지 않지 못함
* Collections 클래스: Collection Framework를 처리한 클래스 제공
* 예) sort: Java 7까지는 collections 인터페이스에 sort기능이 없어서 collections 활용, Java 8부터는 기능 추가
```java
Arrays.sort(str);
Collections.sort(list);
```

## 2.3 인터페이스의 진화 > Java8 이후에는 어떻게 메서드를 추가할 수 있게 된 것일까?
### 2.3.1 인터페이스의 발전 과정
#### 최초 Java 1.x
* 상수 선언 가능, 해당 상수에는 반드시 값이 할당되어 있어야 함. final로 인식하며 값 변경 불가능
* 반드시 추상 메서드여야 함 -> 구현체가 아니라 메서드 명세만 정의되어 있어야 함
* 인터페이스를 구현한 클래스는 인터페이스의 정의한 메서드를 구현하지 않았다면 반드시 추상 클래스로 선언되어야 함
* 인터페이스에 선언된 상수와 메서드는 public으로 인식
```java
/*
 * 인터페이스 선언
 */
public interface Vehicle {
	int SPEED_LIMIT = 200;  // public static final이 생략되어 있다.
	int getSpeedLimit(); // public이 생략되어 있다.
}

/*
 * 인터페이스 구현
 */
public class VehicleImpl implements Vehicle {
	
	public int getSpeedLimit() {  // public 으로 구현해야 컴파일 에러 발생하지 않음
		return Vehicle.SPEED_LIMIT; // SPEED_LIMIT 속성이 public static final로 인식된다.
	}
}
```
#### Java 1.2
* 중첩(Nested) 클래스/인터페이스 선언 가능
  * 중첩 클래스: 클래스/인터페이스 내부에 static으로 선언된 클래스 (Outer 클래스의 객체가 없어도 Inner 클래스의 객체 생성이 가능)
  * 인터페이스 내부의 클래스는 static으로 간주되기 때문에 중첩 클래스임
  * [참고] https://sjh836.tistory.com/145
* 위의 중첩 클래스/인터페이스는 모두 public & static 이며 생략 가능함 
* 인터페이스 내에 중첩 클래스를 정의하면
```java
public interface Input {
  // 입력값에 대한 상세한 정의를 중첩 클래스로 정의함
	public static class KeyEvent {
		public static final int KEY_DOWN = 0;
		public static final int KEY_UP = 1;
		public int type;
		public int keyCode;
		public char keyChar;
	}

	public static class TouchEvent {
		public static final int TOUCH_DOWN = 0;
		public static final int TOUCH_UP = 1;
		public static final int TOUCH_DRAGGED = 2;
		public int type;
		public int x, y;
		public int pointer;
	}
	public int getTouchY(int pointer);
	public List<KeyEvent> getKeyEvents();
	public List<TouchEvent> getTouchEvents();
}
```
